# Round B 2020 - Kick Start 2020

## A Bike Tour

给一个长度为$n$的数组，求满足$w_i > w_{i - 1}$且$w_i > w_{i + 1}$的点的个数，暴力模拟即可，时间复杂度$O(n)$

## B Bus Routes

给一个长度为$n$的数组，要求每$w_i$的倍数的时刻才能向后走，求在$m$时刻前走完对应的最晚出发时刻。

算法：模拟，从后往前取模求最晚出发时刻即可，时间复杂度$O(n)$

## C Robot Path Decoding

给一个长度为$n$的字符串，有两种模式“$\text{NSWE}”和“$n(\text{NSWE})$”，求终点。

算法：递归，默认乘数为$1$，当没有括号时暴力模拟，当遇到左括号时找到对应的右括号，括号内的值为乘数为$n$的子函数的值，时间复杂度约为$O(n)$，最差时间复杂度为$O(n^2)$（为“$1(1(\text{N}))$”）

## D Wandering Robot

给出一个$n \times m$的二维矩阵，其中$l, r, u, d$的区域为黑洞，从左上角走到右下角，每次向右或向下，概率平均分配，求走到终点的概率。

算法：数学，求出以$(u, r)$为分界点向右上和以$(d, l)$为分界点向左下的概率之和，其中点$(x, y)$的概率为$\frac{\text{C}_{x + y - 2}^{x - 1}}{2^{x + y - 2}}$，考虑到浮点误差，将其记录为$2^{\log_2 (x + y - 2) - \log_2 (x - 1) - \log_2 (y - 1) - (x + y - 2)}$，最后一行或最后一列的概率由左下角或右上角递推而来，时间复杂度$O(n)$