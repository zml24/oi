# Round D 2020 - Kick Start 2020

## A Record Breaker

给一个长度为$n$的数组，求大于前面所有数且大于接下来的第一个数的个数，暴力模拟即可，时间复杂度$O(n)$

## B Alien Piano

给一个长度为$n$的数组，求将其转码为$4$种相对大小过程中不满足的次数和。

算法：贪心，连续的四次上升或者下降将导致转码错误，使用两个计数器记录当前连续上升或下降的个数，超过3次则使答案`+1`，且清空计数器，时间复杂度$O(n)$

## C Beauty of tree

给一个$n$个点的树，从树的任意一个节点出发向上到根的路径中所有间隔$i$或$j$次的点点会被染色，求被染色的点的期望。

算法：容斥原理，$P(A \cup B) = P(A) + P(B) - P(AB)$，接着使用$\text{DFS}$后序遍历所有从根到某个点的路径，退出某点前记录`st`数组对应的值`+1`，且对应的间隔$i$或$j$次的点对应的`st`数组的值加上这个点的`st`数组的值，时间复杂度$O(n)$

## D Locked Doors

给一个长度为$n - 1$的数组，表示从$i$到$i + 1$所需要的代价，查询从$s$点出发，每次往代价小的一侧转移，转移$k$次之后的位置。

<!-- 算法：线段树，维护两个信息$sum1 = (-1)^i * w_i$和$sum2 = (-1)^i w_i * i$，执行查询时计算$sum2 - sum1 * (l - 1)$即可，时间复杂度$O(n + mlogn)$ -->