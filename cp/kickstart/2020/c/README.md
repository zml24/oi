# Round C 2020 - Kick Start 2020

## A Countdown

给一个长度为$n$的数组，求长度为$k$的$(k, k - 1, ..., 1)$的个数，从后往前暴力模拟即可，时间复杂度$O(n)$

## B Stable Wall

给$n$个长度为$m$的字符串，求稳定的搭积木方式（从下往上）。

算法：拓扑排序，对于每一列，从下往上字母不同则连边，然后执行拓扑排序并输出顺序，时间复杂度$O(nm)$

## C Perfect Subarray

给一个长度为$n$的数组，求合为完全平方数的子串个数。

算法：在线哈希，首先计算出数组的正元素之和$maximal$和负元素之和$minimal$，根据$maximal$计算出所有可能的完全平方数集合$set$，同时预处理出前缀和数组$s$，从前往后向哈希表中查询是否存在$s_i - set_j$，存在即向答案添加对应的值，接着向哈希表中插入$s_i$，时间复杂度为$O(n \sqrt{10^7} )$

常数优化：使用数组而不是`unordered_map`或`map`进行哈希的计算，计算出的$minimal$即可作为数组基准偏移量

## D Candies

给一个长度为$n$的数组，支持两种操作：修改某个点的值，或者计算$l$到$r$范围内$w_l \times 1 - w_{l + 1} \times 2 + ... + (-1)^{r - l} w_r * (r - l + 1)$的和

算法：树状数组/线段树，维护两个信息$sum1 = (-1)^i * w_i$和$sum2 = (-1)^i w_i * i$，执行查询时计算$sum2 - sum1 * (l - 1)$即可，时间复杂度$O(n + mlogn)$