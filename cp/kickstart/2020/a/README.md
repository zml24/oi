# Round A 2020 - Kick Start 2020

## A Allocation

给一个长度为$n$的数组，求合小于$k$的子序列长度的最大值，排序后贪心从最小值选起即可，时间复杂度$O(n \log n)$

## B Plates

给一个$n \times m$的二维矩形，每次从一行中选择所有小于等于$k$的点，求一共拿走$k$个点的最大权值和。

算法：动态规划，定义$f[i][j]$为前$i$行取$j$个点的最大权值和，状态转移方程为$f_{i, j} = \min(f_{i - 1, j}, f_{i - 1, j - 1}, ... ,f_{i - 1, j - m})$，时间复杂度$O(nm)$

## C Workout

给一个长度为$n$的严格单调递增数组，求在其中插入$k$个数后仍然保持单调递增时的最小差分值。

算法：二分，首先将数组处理成差分数组，接着二分可以成为最小值的答案，判断切分出的区间个数是否合法，时间复杂度$O(n \log (10^5))$

## D Bundling

给出$n$个仅含大写字母的字符串，求将其分为$k$组的公共前缀长度之和。

算法：$trie$树，建树，然后使用后序$\text{DFS}$贪心地计算$count_p >= k$时的$depth_p$，若剩余的$count_p < k$，则将剩余的$count_p上传到父节点$，时间复杂度$O(n)$
