# Round F 2020 - Kick Start 2020

## A ATM Queue

给一个长度为$n$的数组，要求每次最多将其$-m$，求每个点小于等于$0$的先后顺序。表示为$\{$降到$0$的次数，$id\}$之后对其排序即可，时间复杂度$O(n \log n)$

## B Metal Harvest

给$n$个区间和一个数$m$，求用$m$的长度将所有区间完全覆盖的最小个数。

算法：贪心，将区间按照起点从小到大排序，然后依次计算此时所需要的覆盖区间的起点、终点和个数即可，时间复杂度$O(n \log n)$

## C Painters' Duel

给一个行数为$n$的三角形，第$i$行有$2i - 1$个小三角形，$A$和$B$从三角形的某个位置出发，有$m$个点不可达，求其能染色点数的之差的最大值。

算法：博弈论+回溯，当$A$走时，目标函数为$f(A, B) = \max \{ f(A_1, B), f(A_2, B), f(A_3, B) \} + 1$（其中$A_1,A_2,A_3$代表$A$的相邻点），当$A$走时，目标函数为$f(A, B) = \min \{ f(A, B_1), f(A, B_2), f(A, B_3) \} - 1$（其中$B_1,B_2,B_3$代表$B$的相邻点），然后执行$\text{DFS}$直到不能走为止，计算所有情况的目标函数，最差时间复杂度为$O(2^{n^2})$

## D Yeetzhee

给一个$m$面的骰子，掷$n$次，求使得结果为$k$组且个数分别为$a_i$的方案的最小期望。

算法：期望+记忆化搜索，首先将$m$组对应的个数求出来（包括$0$），从小到大排序，然后每次掷出的骰子只要不大于对应数位的个数即可，否则需要重新掷。
