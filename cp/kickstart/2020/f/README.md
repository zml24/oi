# Round F 2020 - Kick Start 2020

## A ATM Queue

给一个长度为$n$的数组，要求每次最多将其$-m$，求每个点小于等于$0$的先后顺序。表示为$\{$降到$0$的次数，$id\}$之后对其排序即可，时间复杂度$O(n \log n)$

## B Metal Harvest

给$n$个区间和一个数$m$，求用$m$的长度将所有区间完全覆盖的最小个数。

算法：贪心，将区间按照起点从小到大排序，然后依次计算此时所需要的覆盖区间的起点、终点和个数即可，时间复杂度$O(n \log n)$

## C Painters' Duel

给一个行数为$n$的三角形，第$i$行有$2i - 1$个小三角形，$A$和$B$从三角形的某个位置出发，有$m$个点不可达，求其能染色点数的之差的最大值。

算法：博弈论+回溯，当$A$走时，目标函数为$f(A, B) = \max \{ f(A_1, B), f(A_2, B), f(A_3, B) \} + 1$（其中$A_1,A_2,A_3$代表$A$的相邻点），当$A$走时，目标函数为$f(A, B) = \min \{ f(A, B_1), f(A, B_2), f(A, B_3) \} - 1$（其中$B_1,B_2,B_3$代表$B$的相邻点），然后执行$\text{DFS}$直到不能走为止，计算所有情况的目标函数，最差时间复杂度为$O(2^{n^2})$

## D Yeetzhee

给一个长度为$n - 1$的数组，表示从$i$到$i + 1$所需要的代价$w$，查询从$s$点出发，每次往代价小的一侧转移，转移$k$次之后的位置。

算法：二分+$\text{RMQ}$，当$k = 1$时，最终的位置就在$s$，否则，每次二分查询从起点左移$mid$步是否合法，最小值为$\max(0, k - 2 - (n - s))$，最大值为$\min(s - 1, k - 2)$，从而获取从$s$点移动$k - 1$次中左移的最大次数，最后再判断一下最后一次移动需要往左还是往右即可。二分的判断函数为左移过程中的最大代价$w_l$小于右移过程中的最大代价$w_r$，而区间最小值可以用$\text{ST}$表完成，时间复杂度$O(n \log n + m \log n)$
