# Round A 2021 - Kick Start 2021

## A K-Goodness String

给一个长度为$n$的字符串，求$s_i != s_{n - i + 1}$的个数，暴力模拟即可，时间复杂度$O(n)$

## B L Shaped Plots

给一个$n \times m$的二维矩形，求形成$L$形区域的个数。

算法：模拟，动态规划找到每个点向四个方向沿伸的长度，暴力枚举每个点，每次选择两个相邻方向，交替枚举长边和短边，时间复杂度$O(nm)$

## C Rabbit House

给一个$n \times m$的二维矩形，求使得相邻点权值不大于$1$所需要添加的值之和。

算法1：贪心，将所有点加入最大堆中，然后循环移出堆顶元素，若堆顶元素的四个相邻元素需要修改（与堆顶元素高度差大于$1$），则添加所需要修改的值，并将修改后的值加入堆中，时间复杂度$O(nmlog(nm))$

算法2：差分约束，根据相邻元素差不超过1建边（$w_a + \Delta w_a <= w_b + \Delta w_b + 1, w_a + \Delta w_a >= w_b + \Delta w_b - 1$），求大于$0$的最小值，使用$\text{SPFA}$算法计算最长路即可，时间复杂度约为$O(nm)$

## D Checksum

给一个$n \times m$的二维矩形，其中一些点缺失，复原的代价为$C_{i, j}$，求复原的最小代价和。

算法：二分图最大生成树，将棋盘按照行和列建模成二分图，若$W_{i, j}$缺失，则在$i$和$n + j$之间建一条边，复原点即删边的代价越小越好。使用$\text{Kruskal}$算法计算最大生成树，非树边即是需要删的边，时间复杂度$O(nmlog(nm))$
