# Round B 2021 - Kick Start 2021

## A Increasing Substring

给一个长度为$n$的数组，求以每个位置结尾的最长上升子串长度，暴力模拟即可，时间复杂度$O(n)$

## B Longest Progression

给一个长度为$n$的数组，求最多修改一个点情况下的最长等差子串的长度。

算法：模拟，动态规划找到每个点向四个方向沿伸的长度，暴力枚举每个点，每次选择两个相邻方向，交替枚举长边和短边，时间复杂度$O(nm)$

## C Consecutive Primes

给一个数$n$，求不大于$n$的最大相邻质数积。

算法：质数判定，不大于$n$的两个质数乘积，可能出现在$\sqrt{n}$左右，或两个都小于$\sqrt{n}$，设对于$\sqrt{n}$的质数最大距离为$k$，枚举$\sqrt{n} - 2k \sim \sqrt{n} + k$之间的每个数，执行试除法质数判定即可，结果就是范围内的最大两个质数的乘积，时间复杂度$O(k \sqrt[4]{n})$

## D Truck Delivery

给一个$n \times m$的二维矩形，其中一些点缺失，复原的代价为$C_{i, j}$，求复原的最小代价和。

算法：二分图最大生成树，将棋盘按照行和列建模成二分图，若$W_{i, j}$缺失，则在$i$和$n + j$之间建一条边，复原点即删边的代价越小越好。使用$\text{Kruskal}$算法计算最大生成树，非树边即是需要删的边，时间复杂度$O(nmlog(nm))$
